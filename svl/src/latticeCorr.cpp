//
//  latticeCorr.cpp
//  
//
//  Created by Arman Garakani on 4/14/17.
//
//

#include "latticeCorr.hpp"


///////////  Lattice Correlation Not Currently Used ///////////


/* genLatticeScores - Helper fct intended for use by
 * rfLatticeCorrelate.  This is a plain vanilla version of the
 * algorithm to generate correlation score for the IM tile pair at
 * each lattice position.
 *
 * Note: No error checking is done here as it is assumed the calling
 * fct has verified all inputs and correctly resized scores.
 */
void genLatticeScores(rcWindow& winI, rcWindow& winM,
                      const rcIPair& latticeOff, const rcIPair& tileDim,
                      vector<vector<double> >& scores,
                      const rsCorrParams& params)
{
    rcCorr res;
    
    /* Do first pass generation of correlation results for all the
     * tile-sized IM window pairs that can be done as a set of adjacent,
     * non-intersecting tiles.
     */
    rcWindow tileI (winI, 0, 0, tileDim.x(), tileDim.y());
    rcWindow tileM (winM, 0, 0, tileDim.x(), tileDim.y());
    
    const rcInt32 lastRow = scores.size() - 1;
    const rcInt32 lastCol = scores[0].size() - 1;
    
    const bool widthNotModulo =
    (latticeOff.x()*lastCol + tileDim.x()) != winI.width();
    const bool heightNotModulo =
    (latticeOff.y()*lastRow + tileDim.y()) != winI.height();
    
    rcUint32 colCount = widthNotModulo ? lastCol - 1 : lastCol;
    
    const rcIPair colUpdate (latticeOff.x(), 0);
    const rcIPair rowUpdate (-(latticeOff.x()*colCount), latticeOff.y());
    
    rcInt32 curRow = 0;
    
    do {
        rcInt32 curCol = 0;
        
        do {
            rfCorrelate(tileI, tileM, params, res);
            scores[curRow][curCol++] = res.r();
        } while (tileI.translate(colUpdate) && tileM.translate(colUpdate));
        
        curRow++;
    } while(tileI.translate(rowUpdate) && tileM.translate(rowUpdate));
    
    /* For second pass, create windows along the right-side and bottom
     * to capture results for any places missed in the first pass.
     */
    if (widthNotModulo) {
        tileI = rcWindow(winI, winI.width() - tileDim.x(), 0,
                         tileDim.x(), tileDim.y());
        tileM = rcWindow(winM, winM.width() - tileDim.x(), 0,
                         tileDim.x(), tileDim.y());
        const rcIPair rowUpdate2(0, latticeOff.y());
        
        curRow = 0;
        
        do {
            rfCorrelate(tileI, tileM, params, res);
            scores[curRow++][lastCol] = res.r();
        } while(tileI.translate(rowUpdate2) && tileM.translate(rowUpdate2));
    }
    
    if (heightNotModulo) {
        tileI = rcWindow(winI, 0, winI.height() - tileDim.y(),
                         tileDim.x(), tileDim.y());
        tileM = rcWindow(winM, 0, winM.height() - tileDim.y(),
                         tileDim.x(), tileDim.y());
        const rcIPair colUpdate2(latticeOff.x(), 0);
        
        rcInt32 curCol = 0;
        
        do {
            rfCorrelate(tileI, tileM, params, res);
            scores[lastRow][curCol++] = res.r();
        } while(tileI.translate(colUpdate2) && tileM.translate(colUpdate2));
    }
    
    if (widthNotModulo && heightNotModulo) {
        tileI = rcWindow(winI, winI.width() - tileDim.x(),
                         winI.height() - tileDim.y(),
                         tileDim.x(), tileDim.y());
        tileM = rcWindow(winM, winM.width() - tileDim.x(),
                         winM.height() - tileDim.y(),
                         tileDim.x(), tileDim.y());
        
        rfCorrelate(tileI, tileM, params, res);
        scores[lastRow][lastCol] = res.r();
    }
}

/* genLatticeScoresUsingPartialSums - Helper fct intended for use by
 * rfLatticeCorrelate. This is a special version of the algorithm to
 * generate a correlation score for the tile IM pair at each lattice
 * position. It only works for the case of the tile windows being
 * exactly twice the size of the lattice offsets.
 *
 * This is done by breaking the IM windows up into a grid of
 * lattice-sized windows and then correlating those windows at the
 * same relative locations. The correlation score for each tiled IM
 * pair is then calculated based upon the sum of the intermediate
 * results generated by rfCorrelate on the 4 lattice-sized windows
 * that it contains.
 *
 * Note: Most error checking is not done here as it is assumed the
 * calling fct has verified all inputs (except workSpaceP) and
 * correctly resized scores.
 */
void genLatticeScoresUsingPartialSums(rcWindow& winI, rcWindow& winM,
                                      const rcIPair& latticeOff,
                                      vector<vector<double> >& scores,
                                      vector<vector<rcCorr> >* workSpaceP,
                                      const rsCorrParams& params)
{
    /* Make sure there is a 2D array of rcCorr objects available to
     * store partial results in.
     */
    vector<vector<rcCorr> > localWorkSpace;
    
    if (!workSpaceP) {
        workSpaceP = &localWorkSpace;
        
        localWorkSpace.resize(scores.size() + 1);
        
        for (rcUint32 i = 0; i < localWorkSpace.size(); i++)
            localWorkSpace[i].resize(scores[0].size() + 1);
    }
    
    vector<vector<rcCorr> >& workSpace = *workSpaceP;
    
    rmAssert(workSpace.size() == (scores.size() + 1));
    for (rcUint32 i = 0; i < workSpace.size(); i++)
        rmAssert(workSpace[i].size() == (scores[0].size() + 1));
    
    /* Figure out how many rows/columns of results can be processed in the
     * first pass.
     */
    const bool widthNotModulo = (winI.width() % latticeOff.x()) != 0;
    const bool heightNotModulo = (winI.height() % latticeOff.y()) != 0;
    const rcUint32 rowCount =
    (heightNotModulo) ? scores.size() - 1 : scores.size();
    const rcUint32 colCount =
    (widthNotModulo) ? scores[0].size() - 1 : scores[0].size();
    
    /* Do first pass generation of correlation statistics for all the
     * lattice-sized IM window pairs that can be done as a set of
     * adjacent, non-intersecting tiles.
     */
    rcWindow tileI (winI, 0, 0, latticeOff.x(), latticeOff.y());
    rcWindow tileM (winM, 0, 0, latticeOff.x(), latticeOff.y());
    
    const rcIPair colUpdate (latticeOff.x(), 0);
    const rcIPair rowUpdate (-(latticeOff.x()*colCount), latticeOff.y());
    
    rcUint32 curRow = 0;
    
    do {
        rcUint32 curCol = 0;
        
        do {
            rfCorrelate(tileI, tileM, params, workSpace[curRow][curCol++]);
            
        } while (tileI.translate(colUpdate) && tileM.translate(colUpdate));
        rmAssert(curCol == (colCount+1));
        
        curRow++;
    } while(tileI.translate(rowUpdate) && tileM.translate(rowUpdate));
    rmAssert(curRow == (rowCount+1));
    
    /* Generate a score at each tile location by summing up the
     * intermediate results for each corresponding group of four
     * lattice-sized window pairs and calling compute to generate a
     * correlation score.
     */
    for (rcUint32 row = 0; row < rowCount; row++)
        for (rcUint32 col = 0; col < colCount; col++) {
            rcCorr result;
            
            result.n(workSpace[row][col].n() + workSpace[row][col+1].n() +
                     workSpace[row+1][col].n() + workSpace[row+1][col+1].n());
            
            result.Si(workSpace[row][col].Si() + workSpace[row][col+1].Si() +
                      workSpace[row+1][col].Si() + workSpace[row+1][col+1].Si());
            
            result.Sm(workSpace[row][col].Sm() + workSpace[row][col+1].Sm() +
                      workSpace[row+1][col].Sm() + workSpace[row+1][col+1].Sm());
            
            result.Sii(workSpace[row][col].Sii() + workSpace[row][col+1].Sii() +
                       workSpace[row+1][col].Sii() + workSpace[row+1][col+1].Sii());
            
            result.Smm(workSpace[row][col].Smm() + workSpace[row][col+1].Smm() +
                       workSpace[row+1][col].Smm() + workSpace[row+1][col+1].Smm());
            
            result.Sim(workSpace[row][col].Sim() + workSpace[row][col+1].Sim() +
                       workSpace[row+1][col].Sim() + workSpace[row+1][col+1].Sim());
            
            scores[row][col] = result.compute();
        }
    
    /* For second pass, create windows along the right-side and bottom
     * to capture results for any places missed in the first pass.
     */
    if (widthNotModulo) {
        tileI = rcWindow(winI, winI.width() - latticeOff.x()*2, 0,
                         latticeOff.x()*2, latticeOff.y());
        tileM = rcWindow(winM, winM.width() - latticeOff.x()*2, 0,
                         latticeOff.x()*2, latticeOff.y());
        const rcIPair rowUpdate2(0, latticeOff.y());
        
        curRow = 0;
        
        const rcUint32 lastCol = colCount + 1;
        
        do {
            rfCorrelate(tileI, tileM, params, workSpace[curRow++][lastCol]);
        } while(tileI.translate(rowUpdate2) && tileM.translate(rowUpdate2));
        
        rmAssert(curRow == (rowCount+1));
        
        /* Sum up intermediate correlation values and generate the final
         * correlation scores.
         */
        for (rcUint32 row = 0; row < rowCount; row++) {
            rcCorr result;
            
            result.n(workSpace[row][lastCol].n() + workSpace[row+1][lastCol].n());
            
            result.Si(workSpace[row][lastCol].Si() + workSpace[row+1][lastCol].Si());
            
            result.Sm(workSpace[row][lastCol].Sm() + workSpace[row+1][lastCol].Sm());
            
            result.Sii(workSpace[row][lastCol].Sii() + workSpace[row+1][lastCol].Sii());
            
            result.Smm(workSpace[row][lastCol].Smm() + workSpace[row+1][lastCol].Smm());
            
            result.Sim(workSpace[row][lastCol].Sim() + workSpace[row+1][lastCol].Sim());
            
            scores[row][colCount] = result.compute();
        }
    } // End of: if (widthNotModulo)
    
    if (heightNotModulo) {
        tileI = rcWindow(winI, 0, winI.height() - latticeOff.y()*2,
                         latticeOff.x(), latticeOff.y()*2);
        tileM = rcWindow(winM, 0, winM.height() - latticeOff.y()*2,
                         latticeOff.x(), latticeOff.y()*2);
        const rcIPair colUpdate2(latticeOff.x(), 0);
        
        rcUint32 curCol = 0;
        
        const rcUint32 lastRow = rowCount + 1;
        
        do {
            rfCorrelate(tileI, tileM, params, workSpace[lastRow][curCol++]);
        } while(tileI.translate(colUpdate2) && tileM.translate(colUpdate2));
        
        rmAssert(curCol == (colCount+1));
        
        /* Sum up intermediate correlation values and generate the final
         * correlation scores.
         */
        rcCorr result;
        for (rcUint32 col = 0; col < colCount; col++) {
            
            result.n(workSpace[lastRow][col].n() + workSpace[lastRow][col+1].n());
            
            result.Si(workSpace[lastRow][col].Si() + workSpace[lastRow][col+1].Si());
            
            result.Sm(workSpace[lastRow][col].Sm() + workSpace[lastRow][col+1].Sm());
            
            result.Sii(workSpace[lastRow][col].Sii() + workSpace[lastRow][col+1].Sii());
            
            result.Smm(workSpace[lastRow][col].Smm() + workSpace[lastRow][col+1].Smm());
            
            result.Sim(workSpace[lastRow][col].Sim() + workSpace[lastRow][col+1].Sim());
            
            scores[rowCount][col] = result.compute();
        }
    } // End of: if (heightNotModulo)
    
    if (widthNotModulo && heightNotModulo) {
        tileI = rcWindow(winI, winI.width() - latticeOff.x()*2,
                         winI.height() - latticeOff.y()*2,
                         latticeOff.x()*2, latticeOff.y()*2);
        tileM = rcWindow(winM, winM.width() - latticeOff.x()*2,
                         winM.height() - latticeOff.y()*2,
                         latticeOff.x()*2, latticeOff.y()*2);
        
        rfCorrelate(tileI, tileM, params, workSpace[rowCount+1][colCount+1]);
        scores[rowCount][colCount] = workSpace[rowCount+1][colCount+1].r();
    }
}

/* rfGenLatticeDimensions - Helper fct to rfLatticeCorrelate that
 * calculates the correct sizes for the scores and workspace 2D arrays.
 *
 * Note: Made a public fct to allow users of rfLatticeCorrelate to
 * preallocate structures of the correct size.
 */
void rfGenLatticeDimensions(const rcRect& geom, const rcIPair& latticeOff,
                            const rcIPair& tileDim, rcUIPair& scoresDim,
                            rcUIPair& workSpaceDim)
{
    rmAssert(latticeOff.x() > 0);
    rmAssert(latticeOff.y() > 0);
    rmAssert(tileDim.x() > 0);
    rmAssert(tileDim.y() > 0);
    rmAssert(tileDim.x() <= (rcInt32)geom.width());
    rmAssert(tileDim.y() <= (rcInt32)geom.height());
    
    /* Calculate the dimensions of the result space.
     */
    const rcInt32 colCount =
    (geom.width() - tileDim.x() + (latticeOff.x() - 1)) / latticeOff.x() + 1;
    
    const rcInt32 rowCount =
    (geom.height() - tileDim.y() + (latticeOff.y() - 1)) / latticeOff.y() + 1;
    
    scoresDim = rcUIPair((rcUint32)colCount, (rcUint32)rowCount);
    workSpaceDim = rcUIPair((rcUint32)colCount + 1, (rcUint32)rowCount + 1);
    
#if 0
    fprintf(stderr, "win WxH %dx%d lattice XOxYO %dx%d tile WxH %dx%d "
            "TILE COUNT RxC %dx%d\n",
            geom.width(), geom.height(), latticeOff.x(), latticeOff.y(),
            tileDim.x(), tileDim.y(), scoresDim.y(), scoresDim.x());
#endif
}

/* rfLatticeCorrelate - Generates a "lattice" of correlation results
 * by creating tiled windows into winI and winM and correlating IM
 * window pairs at the same relative positions. Tiling is controlled
 * by the latticeOff and tileDim parameters.
 *
 * winI and winM are the two images to be carved up into lattices of
 * tiles and correlated. latticeOff determines the amount to move the
 * origin between consecutive tiles. tileDim define the width/height
 * of the tiled windows. workSpaceP allows the caller to provide a
 * scratch array of rcCorr structures that is used when an optimized
 * version of the score generating is used. See comments for
 * genLatticeScoresUsingPartialSums for a description of the
 * conditions required.
 *
 * Note: The returned scores is a vector of vectors of rows of scores.
 * In other words, each element of scores will be a vector of
 * correlation scores for IM tile pairs whose origins are at the same
 * y-offset with respect to winI/winM.
 *
 * Note: For simplicity's sake, the only matching method currently
 * supported is normalized correlation.
 */
void rfLatticeCorrelate(rcWindow& winI, rcWindow& winM, 
                        const rcIPair& latticeOff, const rcIPair& tileDim,
                        vector<vector<double> >& scores,
                        vector<vector<rcCorr> >* workSpaceP,
                        const rsCorrParams& params)
{
    /* Validate the arguments.
     */
    rmAssert(params.match == rcNormalizedCorr); // Add other options later??? xyzzy
    rmAssert(winI.width() == winM.width());
    rmAssert(winI.height() == winM.height());
    
    /* Calculate the dimensions of the result space.
     */
    rcUIPair scoresDim, dummy;
    rfGenLatticeDimensions(winI.rcBound(), latticeOff, tileDim, scoresDim, dummy);
    
    /* Resize the scores array appropriately.
     */
    if (scoresDim.y() != scores.size())
        scores.resize(scoresDim.y());
    
    for (rcUint32 row = 0; row < scoresDim.y(); row++)
        if (scoresDim.x() != scores[row].size())
            scores[row].resize(scoresDim.x());
    
    /* Generate correlation scores for the entire lattice.
     *
     * If the tiles are exactly twice the size of the lattice offsets,
     * then a simple optimization can be performed using a special
     * version of the score generating fct.
     */
    if ((tileDim.x() == latticeOff.x()*2) && (tileDim.y() == latticeOff.y()*2))
        genLatticeScoresUsingPartialSums(winI, winM, latticeOff, scores, 
                                         workSpaceP, params);
    else
        genLatticeScores(winI, winM, latticeOff, tileDim, scores, params);
}


