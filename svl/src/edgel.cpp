

// peaks should not be angle_labled. Just binary > threshold

#if 0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0160179192192192192192192192192192205  0
 0  0  0141160192192192192192192192192192224  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0128128  0  0  0  0  0  0  0  0  0  0  0
 0  0  0115 96 64 64 64 64 64 64 64 64 64 32  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0


 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  8  8  8  8  8  8  8  8  8  0  0
 0  0  0  0  8  8  8  8  8  8  8  8  8  8  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  8  8  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  1  1  1  1  1  1  1  1  1  -1  0

  -1  -1  -1  8  1  1  1  1  1  1  1  1  1  -1  0

  -1  -1  0  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  7  7  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  4  5  5  5  5  5  5  5  5  -1  0

  -1  -1  -1  3  0  5  5  5  5  5  5  5  5  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  3  3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  0  0  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  0

  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

#endif


#include "vision/roiWindow.h"
#include "core/angle_units.h"
#include "vision/gradient.h"
#include "vision/edgel.h"


static EdgeTables sEdgeTables;

feature::feature (const int& x, const int& y, const uAngle8 angle8, const roiWindow<P8U>& src,
                  bool doInterpSubPixel, double weight, bool isMod180, const iPair& half_kernel):
weight_(weight), doSubPixel_(doInterpSubPixel),
isMod180_(isMod180), kernel_(half_kernel)

{
    assert(x < half_kernel.first || y < half_kernel.second ||
           src.width() >= ( x + half_kernel.first ) || src.height() >= ( y + half_kernel.second ));
    
    int magUpdate(src.rowUpdate());
    auto mag = src.pelPointer(x,y);
    int angle = sEdgeTables.getAxis(angle8.basic());
    
    switch (angle)
    {
        case 0:
        case 4:
            neg_val_ = *(mag - 1);
            pos_val_ = *(mag + 1);
            break;
            
        case 1:
        case 5:
            neg_val_ = *(mag - 1 - magUpdate);
            pos_val_ = *(mag + 1 + magUpdate);
            break;
            
        case 2:
        case 6:
            neg_val_ = *(mag - magUpdate);
            pos_val_ = *(mag + magUpdate);
            break;
            
        case 3:
        case 7:
            neg_val_ = *(mag + 1 - magUpdate);
            pos_val_ = *(mag - 1 + magUpdate);
            break;
    }
    
    center_ = *mag;
    
    *this = feature(x, y, center_, angle8, neg_val_, pos_val_);
    
}


bool feature::operator== (const feature& rhs) const
{
    return isValid_ && position_ == rhs.position_ && angle_ == rhs.angle_ && center_ == rhs.center_;
}

size_t edgels::add(const feature& tup)
{
    if (check(tup))
    {
        update (tup);
    }
    return m_probes.size();
}

void edgels::clear()
{
    m_probes.clear();
    m_sum = fVector_2d ();
    m_anchor =   fRect (boost::numeric::bounds<float>::highest(), boost::numeric::bounds<float>::highest(),
                        boost::numeric::bounds<float>::lowest(), boost::numeric::bounds<float>::lowest());
    m_unitsum = fVector_2d ();
}

void edgels::update(const feature& newf)
{
    m_sum += newf.position();
    m_unitsum += newf.unit_vector();
    include (newf.position().x(), newf.position().y());
    m_probes.push_back(newf);
    
}


bool edgels::check(const feature& newf) const
{
    bool  is_in = m_anchor.contains(newf.position().x(), newf.position().y());
    
    return is_in;
}

// Computes the 8-connected direction from the 8 bit angle

// This is the Gradient Direciton. For edgel direction, they have to be rotated 90 degress

// + 2 == adding 90 degrees

static inline int get_edgel_direction(uint8_t val)

{

    int axis = (val + (1 << (8 - 4))) >> (8 - 3);
    axis += 2;
    return axis % 8;
}


void extract(roiWindow<P8U> & mag, roiWindow<P8U> & angle, roiWindow<P8U> & peaks, edgels::directed_features_t  & output, int low_threshold)
{
    output.clear();
    int xdim = peaks.width();
    int ydim = peaks.height();

    typedef std::shared_ptr<int> row_ptr_ref_t;
    typedef std::vector<row_ptr_ref_t> array_ptr_t;
    
    array_ptr_t forward (ydim);
    array_ptr_t backward (ydim);
    
    for (auto i = 0; i < ydim; i++)
    {
        forward[i] = row_ptr_ref_t (new int[xdim]);
        backward[i] = row_ptr_ref_t (new int[xdim]);
        memset(forward[i].get(), 0, xdim * sizeof(int));
        memset(backward[i].get(), 0, xdim * sizeof(int));
    }


    int x, y, ypos, zpos;
    int currX, currY, i;
    int newX, newY;
    fPair vec, vec1, vec2;
    double linkThresh, phiThresh;
    // these direction vectors are rotated 90 degrees
    // to convert gradient direction into edgel direction
    static double directions[8][2] = {
        {0, 1}, {-0.707, 0.707}, {-1, 0}, {-0.707, -0.707}, {0, -1}, {0.707, -0.707}, {1, 0}, {0.707, 0.707}};
    int length, start;
    int bestDirection = 0;
    double error, bestError;



    int pup = peaks.rowUpdate();
    int aup = angle.rowUpdate();

    int xoffset[8] = {1, 1, 0, -1, -1, -1, 0, 1};
    int yoffset[8] = {0, 1, 1, 1, 0, -1, -1, -1};
    int peakyoffset[8] = {0, pup, pup, pup, 0, -pup, -pup, -pup};
    int angleyoffset[8] = {0, aup, aup, aup, 0, -aup, -aup, -aup};

    //    zpos = z*xdim*ydim;
    //    linkThresh = cos(this->LinkThreshold*vtkMath::Pi()/180.0);
    //    phiThresh = cos(this->PhiThreshold*vtkMath::Pi()/180.0);

    // first find all forward & backwards links
    for (y = 1; y < ydim - 1; y++)
    {
        uint8_t * mag_col = mag.pelPointer(1, y);
        uint8_t * peaks_col = peaks.pelPointer(1, y);
        uint8_t * angle_col = angle.pelPointer(1, y);

        for (x = 1; x < xdim - 1; x++, peaks_col++, angle_col++, mag_col++)
        {
            // find forward and backward neighbor for this pixel
            // if its value is less than threshold then ignore it

            if (*peaks_col == 0)
            {
                forward[y].get()[x] = -1;
                backward[y].get()[x] = -1;
            }
            else
            {

                // get edgel direction
                uAngle8 a8(*angle_col);
                vec1.first = static_cast<float>(sin(a8));

                vec1.second = static_cast<float>(cos(a8));
                i = get_edgel_direction(a8.basic());
                int xpos = x + xoffset[i];
                int ypos = y + yoffset[i];

                // make sure it passes the linkThresh test
                bool link_score = directions[i][0] * vec1.first + directions[i][1] * vec1.second;

                if (xpos < 0 || xpos >= xdim) continue;
                if (ypos < 0 || ypos >= ydim) continue;
                if (backward[ypos].get()[xpos]) continue;
                if (peaks.getPixel(xpos, ypos) > 0 || mag.getPixel(x, y) > low_threshold)
                {
                    forward[y].get()[x] = (i + 1);
                    
                    backward[ypos].get()[xpos] = ((i + 4) % 8) + 1;
                }
            }
        }
    }

#if 0
    for (y = 0; y < ydim; y++)
    {
        std::cout << std::endl;
        for (x = 0; x < xdim; x++)
            std::cout << forward[y].get()[x] << "  ";

        std::cout << std::endl;
    }
    for (y = 0; y < ydim; y++)
    {
        std::cout << std::endl;
        for (x = 0; x < xdim; x++)
            std::cout << backward[y].get()[x] << "  ";

        std::cout << std::endl;
    }
#endif

    for (y = 1; y < ydim - 1; y++)
    {
        for (x = 1; x < xdim - 1; x++)
        {
            // do we have part of an edgel chain ?
            // isolated edgels do not qualify
            if (backward[y].get()[x] > 0)
            {
                // trace back to the beginning
                currX = x;
                currY = y;
                do
                {
                    newX = currX + xoffset[backward[currY].get()[currX] - 1];
                    currY += yoffset[backward[currY].get()[currX] - 1];
                    currX = newX;
                } while ((currX != x || currY != y) && backward[currY].get()[currX]);


                // now trace to the end and build the digital curve
                length = 0;
                edgels newedgels;
                newX = currX;
                newY = currY;
                do
                {
                    currX = newX;
                    currY = newY;
                    feature f (currX, currY, uAngle8(angle.getPixel(currX, currY)), mag);
                    newedgels.add(f);

                    length++;

                    // if there is a next pixel select it
                    int forward_index = forward[currY].get()[currX];
                    if (forward_index > 0)
                    {
                        newX = currX + xoffset[forward[currY].get()[currX] - 1];
                        newY = currY + yoffset[forward[currY].get()[currX] - 1];
                    }
                    // clear out this edgel now that were done with it
                    backward[newY].get()[newX] = 0;
                    forward[currY].get()[currX] = 0;
                } while ((currX != newX || currY != newY));

                output.push_back(newedgels);
            }
        }
    }
}
